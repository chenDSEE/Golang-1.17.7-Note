package main

func inlineFunc(val int) int {
	return val
}

//go:noinline
func noinlineFunc(val int) int {
	return val
}

type inlineInterface interface {
	inlineMethod() inlineVar
	noinlineMethod() inlineVar
}

type inlineVar int

var _ inlineInterface = inlineVar(0)

func (v inlineVar) inlineMethod() inlineVar {
	return v
}

//go:noinline
func (v inlineVar) noinlineMethod() inlineVar {
	return v
}

// fast path and slow path
// NOTE: only when return at first, can fast path make best effect
func slowPath(data []int) int {
	if len(data) >= 0 {
		return 0
	}

	var sum int
	for _, val := range data {
		if sum < 0 {
			sum = sum - val
		} else {
			sum = sum + val
		}
	}

	return sum
}

func fastPath(data []int) int {
	if len(data) >= 0 {
		return 0
	}

	return something(data)
}

func something(data []int) int {
	var sum int
	for _, val := range data {
		if sum < 0 {
			sum = sum - val
		} else {
			sum = sum + val
		}
	}

	return sum
}

func main() {
	// function call
	inlineFunc(0) // can inline
	noinlineFunc(0)

	// method call
	v := inlineVar(10) // not escapes to heap
	v.inlineMethod()   // can inline
	v.noinlineMethod()

	// interface call
	iv := inlineVar(10)
	var i inlineInterface
	i = iv           // making iv escapes to heap
	i.inlineMethod() // can not inline !!!
	i.noinlineMethod()

	// interface type assert call
	typeAssert := i.(inlineVar)
	typeAssert.inlineMethod() // can inline
	typeAssert.noinlineMethod()

	// fast path and slow path
	data := []int{10, 20, 30}
	fastPath(data)
	slowPath(data) // can not inline
}

/*
[root@LC benchmark]# go build -gcflags='-m=2' inline.go
# command-line-arguments
./inline.go:3:6: can inline inlineFunc with cost 2 as: func(int) int { return val }
./inline.go:8:6: cannot inline noinlineFunc: marked go:noinline
./inline.go:21:6: can inline inlineVar.inlineMethod with cost 2 as: method(inlineVar) func() inlineVar { return v }
./inline.go:26:6: cannot inline inlineVar.noinlineMethod: marked go:noinline
--> (slow path can not inline)
--> ./inline.go:31:6: cannot inline slowPath: unhandled op RANGE
--> ./inline.go:56:6: cannot inline something: unhandled op RANGE
./inline.go:48:6: can inline fastPath with cost 68 as: func([]int) int { if len(data) <= 0 { return 0 }; return something(data) }
./inline.go:69:6: cannot inline main: function too complex: cost 479 exceeds budget 80
--> ./inline.go:71:12: inlining call to inlineFunc func(int) int { return val }
--> ./inline.go:76:16: inlining call to inlineVar.inlineMethod method(inlineVar) func() inlineVar { return v }
--> ./inline.go:88:25: inlining call to inlineVar.inlineMethod method(inlineVar) func() inlineVar { return v }

--> fast path can inline, but not slow path
--> ./inline.go:93:10: inlining call to fastPath func([]int) int { if len(data) <= 0 { return 0 }; return something(data) }
./inline.go:31:15: data does not escape
./inline.go:56:16: data does not escape
./inline.go:48:15: data does not escape
--> interface making `iv` escapes to heap, but no `v`
--> ./inline.go:82:4: iv escapes to heap:
./inline.go:82:4:   flow: i = &{storage for iv}:
./inline.go:82:4:     from iv (spill) at ./inline.go:82:4
./inline.go:82:4:     from i = iv (assign) at ./inline.go:82:4
./inline.go:82:4:   flow: {heap} = i:
./inline.go:82:4:     from i.inlineMethod() (call parameter) at ./inline.go:83:16
./inline.go:82:4: iv escapes to heap
./inline.go:92:15: []int{...} does not escape
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.inlineMethod() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: parameter .this leaks to {heap} with derefs=0:
<autogenerated>:1:   flow: {heap} = .this:
<autogenerated>:1:     from .this.noinlineMethod() (call parameter) at <autogenerated>:1
<autogenerated>:1: leaking param: .this
<autogenerated>:1: inlining call to inlineVar.inlineMethod method(inlineVar) func() inlineVar { return v }
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
[root@LC benchmark]#
*/
